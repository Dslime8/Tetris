<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Tetris</title>
  <link rel="icon" type="image/png" href="Tetris.png">
  <style>
    :root{
      --bg: #111;
      --panel-bg: #1e1e1e;
      --canvas-bg: #000;
      --button-bg: #3a3a3a;
      --slot-bg: var(--canvas-bg);
      --grid-line: rgba(255,255,255,0.12);
      --option-ring: #000;
    }
    :root[data-theme="blue"]{
      --bg: #010617;
      --panel-bg: #041017;
      --canvas-bg: #00040a;
      --button-bg: #0e2730;
      --slot-bg: var(--canvas-bg);
      --grid-line: rgba(170,200,220,0.10);
      --option-ring: #000;
    }
    :root[data-theme="red"]{
      --bg: #120606;
      --panel-bg: #1a0707;
      --canvas-bg: #040202;
      --button-bg: #3a0b0b;
      --slot-bg: var(--canvas-bg);
      --grid-line: rgba(255,180,180,0.10);
      --option-ring: #000;
    }
    :root[data-theme="purple"]{
      --bg: #0a0210;
      --panel-bg: #12071a;
      --canvas-bg: #06020a;
      --button-bg: #2a1030;
      --slot-bg: var(--canvas-bg);
      --grid-line: rgba(200,160,255,0.08);
      --option-ring: #000;
    }
    :root[data-theme="default"]{
      --bg: #111;
      --panel-bg: #1e1e1e;
      --canvas-bg: #000;
      --button-bg: #3a3a3a;
      --slot-bg: var(--canvas-bg);
      --grid-line: rgba(255,255,255,0.12);
      --option-ring: #000;
    }
    *{box-sizing:border-box;font-family:Consolas,monospace}
    body{
      display:flex;
      gap:20px;
      align-items:flex-start;
      justify-content:center;
      padding:24px;
      background:var(--bg);
      color:#e6eef8;
    }
    .wrap{display:grid;grid-template-columns:auto 220px;gap:20px;align-items:start}
    canvas{background:var(--canvas-bg);border-radius:8px;box-shadow:0 6px 18px rgba(0,0,0,.6)}
    .panel{width:220px;padding:12px;background:var(--panel-bg);border-radius:8px;color:#e6eef8}
    h1{font-size:18px;margin:0 0 8px}
    .stat{display:flex;justify-content:space-between;margin:6px 0}
    .controls{font-size:13px;line-height:1.6;color:#e6eef8}
    button{width:100%;padding:8px;border-radius:6px;border:0;background:var(--button-bg);color:#e6eef8;cursor:pointer}
    small{color:#94a3b8}
    a[href*="github"]:hover { background: white !important; }
    a[href*="github"]:hover svg { fill: black !important; }
    .wasd-toggle {
      position: fixed;
      top: 1em;
      right: 1em;
      display: flex;
      align-items: center;
      gap: .75em;
      font-size: 13px;
      color: #e6eef8;
    }
    .switch {
      display: inline-block;
      width: 3em;
      height: 1.5em;
      position: relative;
    }
    .switch input { opacity: 0; width: 0; height: 0; }
    .slider {
      position: absolute;
      cursor: pointer;
      inset: 0;
      background-color: #555;
      border-radius: 1.5em;
      transition: .18s;
    }
    .slider:before {
      position: absolute;
      content: "";
      height: 1.1em;
      width: 1.1em;
      left: 0.2em;
      bottom: 0.2em;
      background-color: white;
      border-radius: 50%;
      transition: .18s;
    }
    input:checked + .slider { background-color: #4caf50; }
    input:checked + .slider:before { transform: translateX(1.5em); }
    .theme-row {
      position: fixed;
      top: 3.1em;
      right: 1em;
      display:flex;
      align-items:center;
      gap:.6em;
      color:#e6eef8;
      font-size:13px;
    }
    .theme-options {
      display:flex;
      gap:.5em;
      align-items:center;
    }
    .theme-input { display:none; }
    .theme-option {
      display:inline-flex;
      align-items:center;
      justify-content:center;
      width:24px;
      height:24px;
      padding:0;
      border-radius:50%;
      border:1px solid var(--option-ring);
      background:transparent;
      cursor:pointer;
      transition:.12s;
      box-sizing:content-box;
    }
    .theme-option.ring-hidden {
      border:1px solid transparent !important;
      border-color: transparent !important;
    }
    
    .theme-option .dot {
      width:20px;
      height:20px;
      border-radius:50%;
      display:block;
    }
    .theme-option[data-theme="default"] .dot { background: #3a3a3a; }
    .theme-option[data-theme="blue"] .dot    { background: #0000ff; }
    .theme-option[data-theme="red"] .dot     { background: #ff0000; }
    .theme-option[data-theme="purple"] .dot  { background: #8000ff; }
    .theme-input:checked + label.theme-option {
      border-color: #fff;
    }
    .slot {
      width:52px;
      height:52px;
      background:var(--slot-bg);
      border-radius:6px;
      display:flex;
      align-items:center;
      justify-content:center;
    }
  </style>
</head>
<body>
  <a href="https://github.com/Dslime8" target="_blank" style="position:fixed;bottom:1em;right:1em;width:3em;height:3em;display:flex;align-items:center;justify-content:center;border-radius:50%;background:black;transition:.2s;">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="white" width="1.5em" height="1.5em" style="transition:.2s;">
      <path d="M12 .5C5.65.5.5 5.65.5 12c0 5.1 3.3 9.4 7.9 10.9.6.1.8-.3.8-.6v-2.1c-3.2.7-3.9-1.5-3.9-1.5-.6-1.5-1.3-1.9-1.3-1.9-1.1-.8.1-.8.1-.8 1.2.1 1.8 1.2 1.8 1.2 1 .1.6 2.3 3.4 1.7 0-.9.4-1.5.8-1.9-2.5-.3-5.1-1.3-5.1-5.7 0-1.3.5-2.3 1.2-3.1-.1-.3-.5-1.6.1-3.3 0 0 1-.3 3.2 1.2a11 11 0 0 1 5.8 0c2.2-1.5 3.2-1.2 3.2-1.2.6 1.7.2 3 .1 3.3.8.8 1.2 1.8 1.2 3.1 0 4.4-2.6 5.4-5.1 5.7.4.4.8 1.1.8 2.3v3.4c0 .3.2.7.8.6A11.5 11.5 0 0 0 23.5 12C23.5 5.65 18.35.5 12 .5z"/>
    </svg>
  </a>
  <div class="wasd-toggle">
    <span>Use WASD</span>
    <label class="switch">
      <input type="checkbox" id="wasdToggle">
      <span class="slider"></span>
    </label>
  </div>
  <div class="theme-row">
    <span>Theme</span>
    <div class="theme-options">
      <input type="radio" name="theme" id="theme-default" class="theme-input" value="default">
      <label class="theme-option" data-theme="default" for="theme-default"><span class="dot"></span></label>
      <input type="radio" name="theme" id="theme-blue" class="theme-input" value="blue">
      <label class="theme-option" data-theme="blue" for="theme-blue"><span class="dot"></span></label>
      <input type="radio" name="theme" id="theme-red" class="theme-input" value="red">
      <label class="theme-option" data-theme="red" for="theme-red"><span class="dot"></span></label>
    </div>
  </div>
  <div class="wrap">
    <div>
      <canvas id="board" width="280" height="560"></canvas>
    </div>
    <div class="panel">
      <h1>Tetris</h1>
      <div class="stat"><span>High Score</span><strong id="highscore">0</strong></div>
      <div class="stat"><span>Score</span><strong id="score">0</strong></div>
      <div class="stat"><span>Lines</span><strong id="lines">0</strong></div>
      <div class="stat"><span>Level</span><strong id="level">1</strong></div>
      <div style="height:10px"></div>
      <div style="display:flex;gap:8px;margin-bottom:8px">
        <button id="start">Start</button>
        <button id="pause">Pause</button>
      </div>
      <div style="height:8px"></div>
      <div><small>Controls</small></div>
      <div class="controls">
        <strong>Keyboard</strong>
        <ul>
          <li>← → : Move</li>
          <li>↑ : Rotate</li>
          <li>↓ : Drop faster</li>
          <li>Shift : Hold piece</li>
        </ul>
      </div>
      <div style="height:12px"></div>
      <div>
        <small>Hold</small>
        <div id="hold" style="height:64px;margin-top:8px;background:var(--slot-bg);border-radius:6px;display:flex;align-items:center;justify-content:center;color:#7c93a9">—</div>
      </div>
      <div style="height:8px"></div>
      <div>
        <small>Next</small>
        <div id="next" style="display:flex;gap:6px;margin-top:8px"></div>
      </div>
    </div>
  </div>
  <script>
    const COLS=10,ROWS=20,BLOCK=28;
    const COLORS={I:'#67e8f9',J:'#60a5fa',L:'#fb923c',O:'#facc15',S:'#34d399',T:'#a78bfa',Z:'#f87171'};
    const PIECES = {
      I:[['....','IIII','....','....'],['..I.','..I.','..I.','..I.']],
      J:[['J..','JJJ','...'],['.JJ','.J.','.J.'],['...','JJJ','..J'],['.J.','.J.','JJ.']],
      L:[['..L','LLL','...'],['.L.','.L.','.LL'],['...','LLL','L..'],['LL.','.L.','.L.']],
      O:[['OO','OO']],
      S:[['.SS','SS.','...'],['.S.','.SS','..S']],
      T:[['.T.','TTT','...'],['.T.','.TT','.T.'],['...','TTT','.T.'],['.T.','TT.','.T.']],
      Z:[['ZZ.','.ZZ','...'],['..Z','.ZZ','.Z.']]
    };
    function shapeToRotations(s){
      return s.map(g=>{
        const cells=[];
        for(let y=0;y<g.length;y++){
          for(let x=0;x<g[0].length;x++){
            if(g[y][x]!=='.') cells.push([x,y]);
          }
        }
        return {cells,w:g[0].length,h:g.length};
      });
    }
    const SHAPES={};
    for(const k in PIECES) SHAPES[k]=shapeToRotations(PIECES[k]);
    const canvas=document.getElementById('board'),ctx=canvas.getContext('2d');
    canvas.width=COLS*BLOCK;canvas.height=ROWS*BLOCK;
    let grid=createEmptyGrid(),score=0,lines=0,level=1,current=null,nextQueue=[],holdPiece=null,holdLocked=false,dropInterval=800,lastDrop=0,running=false,paused=false;
    let softDropHeld=false,leftHeld=false,rightHeld=false,lastSideMove=0;
    const SIDE_MOVE_INTERVAL=100;
    const scoreEl=document.getElementById('score'),
          highScoreEl=document.getElementById('highscore'),
          linesEl=document.getElementById('lines'),
          levelEl=document.getElementById('level'),
          nextEl=document.getElementById('next'),
          holdEl=document.getElementById('hold');
    const startBtn=document.getElementById('start');
    const pauseBtn=document.getElementById('pause');
    let highScore=parseInt(localStorage.getItem("tetrisHighScore"))||0;
    highScoreEl.textContent=highScore;
    startBtn.onclick=()=>{
      if(!running){ startGame(); }
      else { restartGame(); }
    };
    pauseBtn.onclick=()=>{
      if(!running) return;
      paused=!paused;
      updateButtonLabels();
    };
    function updateButtonLabels(){
      startBtn.textContent=running?"Restart":"Start";
      pauseBtn.textContent=paused?"Unpause":"Pause";
    }
    function createEmptyGrid(){
      return Array.from({length:ROWS},()=>Array(COLS).fill(null));
    }
    function randBag(){
      const t=Object.keys(SHAPES),b=[];
      while(t.length) b.push(t.splice(Math.floor(Math.random()*t.length),1)[0]);
      return b;
    }
    function refillQueue(){
      if(nextQueue.length<7) nextQueue=nextQueue.concat(randBag());
    }
    function spawn(){
      if(!running) return;
      refillQueue();
      const type=nextQueue.shift();
      current={type,rot:0,x:Math.floor((COLS-SHAPES[type][0].w)/2),y:0};
      holdLocked=false;
      if(collides(current)){
        running=false;
        resetInputState();
        updateButtonLabels();
        grid=createEmptyGrid();
        current=null;
        draw();
        if(score>highScore){
          highScore=score;
          localStorage.setItem("tetrisHighScore",highScore);
          highScoreEl.textContent=highScore;
        }
        alert('Game Over — score: '+score);
        return;
      }
      updateHud();
    }
    function collides(p,dx=0,dy=0,drot=0){
      const rot=(p.rot+drot)%SHAPES[p.type].length,shape=SHAPES[p.type][rot];
      for(const[sx,sy] of shape.cells){
        const x=p.x+sx+dx,y=p.y+sy+dy;
        if(x<0||x>=COLS||y>=ROWS) return true;
        if(y>=0 && grid[y][x]) return true;
      }
      return false;
    }
    function lockPiece(){
      for(const[sx,sy] of SHAPES[current.type][current.rot].cells){
        const x=current.x+sx,y=current.y+sy;
        if(y>=0) grid[y][x]=current.type;
      }
      clearLines();
      spawn();
    }
    function clearLines(){
      let removed=0;
      for(let y=ROWS-1;y>=0;y--){
        if(grid[y].every(c=>c!==null)){
          grid.splice(y,1);
          grid.unshift(Array(COLS).fill(null));
          removed++;
          y++;
        }
      }
      if(removed>0){
        lines+=removed;
        score+=[0,40,100,300,1200][removed]*level;
        level=Math.floor(lines/10)+1;
        dropInterval=Math.max(100,800-(level-1)*60);
      }
      updateHud();
    }
    function updateHud(){
      scoreEl.textContent=score;
      linesEl.textContent=lines;
      levelEl.textContent=level;
      updateButtonLabels();
      nextEl.innerHTML='';
      for(let i=0;i<4;i++){
        const t=nextQueue[i];
        const slot=document.createElement('div');
        slot.className='slot';
        if(t) slot.appendChild(drawMiniPiece(t));
        nextEl.appendChild(slot);
      }
      holdEl.innerHTML='';
      if(holdPiece) holdEl.appendChild(drawMiniPiece(holdPiece));
      else holdEl.textContent='—';
    }
    function drawMiniPiece(type){
      const box=document.createElement('div');
      box.style.cssText='width:36px;height:36px;display:grid;grid-template-columns:repeat(4,1fr);grid-template-rows:repeat(4,1fr)';
      const cells=SHAPES[type][0].cells;
      const minx=Math.min(...cells.map(c=>c[0]));
      const miny=Math.min(...cells.map(c=>c[1]));
      for(let y=0;y<4;y++){
        for(let x=0;x<4;x++){
          const c=document.createElement('div');
          if(cells.some(([cx,cy])=>cx-minx===x && cy-miny===y)){
            c.style.background=COLORS[type];
            c.style.borderRadius='3px';
          }
          box.appendChild(c);
        }
      }
      return box;
    }
    const keys={};
    let useWasd=localStorage.getItem("useWasd")==="true";
    const toggle=document.getElementById("wasdToggle");
    toggle.checked=useWasd;
    toggle.addEventListener("change",()=>{
      useWasd=toggle.checked;
      localStorage.setItem("useWasd",useWasd);
    });
    window.addEventListener('keydown',e=>{
      if(!running||paused||keys[e.code]) return;
      keys[e.code]=true;
      if(useWasd){
        if(e.key==='a'||e.key==='A') leftHeld=true;
        if(e.key==='d'||e.key==='D') rightHeld=true;
        if(e.key==='s'||e.key==='S') softDropHeld=true;
        if(e.key==='w'||e.key==='W') rotate(1);
      } else {
        if(e.code==='ArrowLeft') leftHeld=true;
        if(e.code==='ArrowRight') rightHeld=true;
        if(e.code==='ArrowDown') softDropHeld=true;
        if(e.code==='ArrowUp') rotate(1);
      }
      if(e.code==='ShiftLeft'||e.code==='ShiftRight') hold();
    });
    window.addEventListener('keyup',e=>{
      keys[e.code]=false;
      if(useWasd){
        if(e.key==='a'||e.key==='A') leftHeld=false;
        if(e.key==='d'||e.key==='D') rightHeld=false;
        if(e.key==='s'||e.key==='S') softDropHeld=false;
      } else {
        if(e.code==='ArrowLeft') leftHeld=false;
        if(e.code==='ArrowRight') rightHeld=false;
        if(e.code==='ArrowDown') softDropHeld=false;
      }
    });
    function move(d){ if(current && !collides(current,d,0)) current.x+=d; }
    function softDrop(){
      if(!current) return;
      if(!collides(current,0,1)){
        current.y++;
      } else {
        lockPiece();
      }
    }
    function rotate(d){
      if(!current) return;
      const old=current.rot,len=SHAPES[current.type].length;
      current.rot=(current.rot+(d>0?1:len-1))%len;
      const kicks=[[0,0],[1,0],[-1,0],[2,0],[-2,0],[0,-1]];
      for(const[kx,ky] of kicks){
        if(!collides(current,kx,ky)){
          current.x+=kx;
          current.y+=ky;
          return;
        }
      }
      current.rot=old;
    }
    function hold(){
      if(holdLocked) return;
      if(!holdPiece){
        holdPiece=current.type;
        spawn();
      } else {
        const old=holdPiece;
        holdPiece=current.type;
        current={type:old,rot:0,x:Math.floor((COLS-SHAPES[old][0].w)/2),y:0};
        if(collides(current)){
          running=false;
          updateButtonLabels();
          grid=createEmptyGrid();
          current=null;
          draw();
          if(score>highScore){
            highScore=score;
            localStorage.setItem("tetrisHighScore",highScore);
            highScoreEl.textContent=highScore;
          }
          alert('Game Over - score: '+score);
          return;
        }
      }
      holdLocked=true;
      updateHud();
    }
    function draw(){
      const canvasBg = getComputedStyle(document.documentElement).getPropertyValue('--canvas-bg').trim() || '#000';
      ctx.clearRect(0,0,canvas.width,canvas.height);
      ctx.fillStyle=canvasBg;
      ctx.fillRect(0,0,canvas.width,canvas.height);
      for(let y=0;y<ROWS;y++){
        for(let x=0;x<COLS;x++){
          const t=grid[y][x];
          if(t) drawCell(x,y,COLORS[t]);
        }
      }
      if(current){
        const ghost={...current};
        while(!collides(ghost,0,1)) ghost.y++;
        drawPiece(ghost,true);
        drawPiece(current,false);
      }
      ctx.strokeStyle=getComputedStyle(document.documentElement).getPropertyValue('--grid-line').trim() || 'rgba(255,255,255,0.12)';
      ctx.lineWidth=1;
      for(let x=0;x<=COLS;x++){ ctx.beginPath(); ctx.moveTo(x*BLOCK,0); ctx.lineTo(x*BLOCK,ROWS*BLOCK); ctx.stroke(); }
      for(let y=0;y<=ROWS;y++){ ctx.beginPath(); ctx.moveTo(0,y*BLOCK); ctx.lineTo(COLS*BLOCK,y*BLOCK); ctx.stroke(); }
    }
    function drawPiece(p,ghost=false){
      for(const[sx,sy] of SHAPES[p.type][p.rot].cells){
        const x=p.x+sx,y=p.y+sy;
        if(y>=0) drawCell(x,y,ghost?shade(COLORS[p.type],-40):COLORS[p.type]);
      }
    }
    function drawCell(x,y,color){
      const px=x*BLOCK,py=y*BLOCK;
      ctx.fillStyle=color;
      ctx.fillRect(px+1,py+1,BLOCK-2,BLOCK-2);
      ctx.fillStyle='rgba(0,0,0,0.18)';
      ctx.fillRect(px+1,py+BLOCK-8,BLOCK-2,6);
    }
    function shade(hex,p){
      const f=parseInt(hex.slice(1),16),t=p<0?0:255,pr=Math.abs(p)/100,
            R=f>>16,G=(f>>8)&0x00FF,B=f&0x0000FF;
      return '#'+( (Math.round((t-R)*pr)+R<<16) | (Math.round((t-G)*pr)+G<<8) | (Math.round((t-B)*pr)+B) ).toString(16).padStart(6,'0');
    }
    function resetInputState(){ softDropHeld=false; leftHeld=false; rightHeld=false; for(const k in keys) keys[k]=false; }
    function update(ts){
      if(!running) return;
      if(paused){ draw(); requestAnimationFrame(update); return; }
      if(!lastDrop) lastDrop=ts;
      const interval=softDropHeld?50:dropInterval;
      if(ts-lastDrop>interval){
        if(!collides(current,0,1)) current.y++;
        else lockPiece();
        lastDrop=ts;
      }
      if(!lastSideMove) lastSideMove=ts;
      if(ts-lastSideMove>SIDE_MOVE_INTERVAL){
        if(leftHeld) move(-1);
        else if(rightHeld) move(1);
        lastSideMove=ts;
      }
      draw();
      requestAnimationFrame(update);
    }
    function startGame(){
      resetInputState();
      grid=createEmptyGrid(); score=0; lines=0; level=1; dropInterval=800; lastDrop=0; lastSideMove=0; nextQueue=[]; holdPiece=null; holdLocked=false; current=null;
      refillQueue(); refillQueue();
      running=true; paused=false; updateButtonLabels();
      spawn(); updateHud();
      requestAnimationFrame(update);
    }
    function restartGame(){ startGame(); }
    const themeInputs = document.querySelectorAll('.theme-input');
    function applyTheme(name){
      if(!name) name='default';
      document.documentElement.setAttribute('data-theme', name);
      localStorage.setItem('tetrisTheme', name);
      const input = document.querySelector(`.theme-input[value="${name}"]`);
      if(input) input.checked = true;
      document.querySelectorAll('.slot').forEach(s => {
        s.style.background = getComputedStyle(document.documentElement).getPropertyValue('--slot-bg');
      });
      holdEl.style.background = getComputedStyle(document.documentElement).getPropertyValue('--slot-bg');
      draw();
    }
    themeInputs.forEach(inp=>{
      inp.addEventListener('change', ()=> applyTheme(inp.value));
    });
    const savedTheme = localStorage.getItem('tetrisTheme') || 'default';
    applyTheme(savedTheme);
    updateButtonLabels();
    draw();
    updateHud();
  </script>

  <script>
  (function(){
    const SEQ_REQUIRED = 5;
    const DURATION = 700;
    const EASING = 'cubic-bezier(.22,.9,.32,1)';
    const THEME_KEY = 'tetrisTheme';

    let blueCount = 0, redCount = 0, unlocked = false;

    const themeBar = document.querySelector('.theme-options');
    const blueLabel = document.querySelector('label.theme-option[data-theme="blue"]');
    const redLabel  = document.querySelector('label.theme-option[data-theme="red"]');
    const blueInput = document.getElementById('theme-blue');
    const redInput  = document.getElementById('theme-red');

    if(!themeBar || !blueLabel || !redLabel) return;

    function resetSeq(){ blueCount = 0; redCount = 0; }

    themeBar.addEventListener('click', (e) => {
      const lbl = e.target.closest('label.theme-option');
      if(!lbl) return;

      if(lbl.textContent.trim() === '←'){
        revertToNormal();
        return;
      }

      if(unlocked) return;

      const theme = lbl.getAttribute('data-theme');
      if(theme === 'blue'){
        blueCount++;
        redCount = 0;
        if(blueCount > SEQ_REQUIRED){
          resetSeq();
          blueCount = 1;
        }
      } else if(theme === 'red'){
        if(blueCount === SEQ_REQUIRED){
          redCount++;
          if(redCount > SEQ_REQUIRED){
            resetSeq();
          } else if(redCount === SEQ_REQUIRED){
            unlockPurpleTheme();
          }
        } else {
          resetSeq();
        }
      } else {
        resetSeq();
      }
    });

    function ensureDot(label, themeName){
      let d = label.querySelector('.dot');
      if(!d){
        label.textContent = '';
        d = document.createElement('span');
        d.className = 'dot';
        label.appendChild(d);
        label.setAttribute('data-theme', themeName);
      }
      return d;
    }

    function unlockPurpleTheme(){
      unlocked = true;
      resetSeq();

      const blueDot = ensureDot(blueLabel, 'blue');
      const redDot  = ensureDot(redLabel, 'red');

      const redRect = redDot.getBoundingClientRect();
      const blueRect = blueDot.getBoundingClientRect();

      const from = { x: redRect.left + redRect.width/2, y: redRect.top + redRect.height/2 };
      const to   = { x: blueRect.left + blueRect.width/2, y: blueRect.top + blueRect.height/2 };
      const dx = to.x - from.x;
      const dy = to.y - from.y;

      const clone = redDot.cloneNode(true);
      clone.style.position = 'fixed';
      clone.style.left = from.x + 'px';
      clone.style.top  = from.y + 'px';
      clone.style.transform = 'translate(-50%,-50%)';
      clone.style.width = redRect.width + 'px';
      clone.style.height = redRect.height + 'px';
      clone.style.borderRadius = '50%';
      clone.style.pointerEvents = 'none';
      clone.style.zIndex = 9999;
      clone.style.background = getComputedStyle(redDot).backgroundColor || '#ff0000';
      document.body.appendChild(clone);

      const redOriginalDot = redDot;
      redOriginalDot.remove();

      const anim = clone.animate([
        { transform: 'translate(-50%,-50%) translate(0px,0px)', background: getComputedStyle(redOriginalDot).backgroundColor || '#ff0000' },
        { transform: `translate(-50%,-50%) translate(${dx}px, ${dy}px)`, background: '#8000ff' }
      ], { duration: DURATION, easing: EASING, fill: 'forwards' });

      requestAnimationFrame(()=> {
        setTimeout(()=> {
          blueDot.style.transition = `background ${DURATION}ms ${EASING}`;
          blueDot.style.background = '#8000ff';
	        blueLabel.classList.add('ring-hidden');
          redLabel.classList.add('ring-hidden');
        }, 10);
      });

      anim.onfinish = () => {
        applyTheme('purple');

        blueLabel.setAttribute('data-theme', 'purple');
        if(blueInput) {
          blueInput.value = 'purple';
          blueInput.checked = true;
        }

        redLabel.textContent = '←';
       	blueLabel.classList.remove('ring-hidden');

        try{ localStorage.setItem(THEME_KEY, 'purple'); }catch(e){}

        setTimeout(()=> { try{ clone.remove(); }catch(e){} }, 400);

        setTimeout(()=> { blueDot.style.transition = ''; }, DURATION + 100);
      };
    }

    function revertToNormal(){
      unlocked = false;
      resetSeq();

      blueLabel.setAttribute('data-theme', 'blue');
      if(blueInput) { blueInput.value = 'blue'; blueInput.checked = true; }
      const bdot = ensureDot(blueLabel, 'blue');
      bdot.style.background = '#0000ff';

      redLabel.textContent = '';
      const rdot = document.createElement('span');
      rdot.className = 'dot';
      redLabel.appendChild(rdot);
      redLabel.setAttribute('data-theme', 'red');
      if(redInput) { redInput.value = 'red'; redInput.checked = false; }
      rdot.style.background = '#ff0000';

      applyTheme('blue');

      try{ localStorage.setItem(THEME_KEY, 'blue'); }catch(e){}

      redLabel.classList.remove('ring-hidden');
    }

    if(localStorage.getItem(THEME_KEY) === 'purple'){
      unlocked = true;
      blueLabel.setAttribute('data-theme','purple');
      if(blueInput) { blueInput.value = 'purple'; blueInput.checked = true; }
      redLabel.textContent = '←';
      redLabel.classList.add('ring-hidden');
      applyTheme('purple');
    }
  })();
  </script>
</body>
</html>
